`first-class functions`
(Add(x = 3 -> int; y = 3 -> int)) int
	<*>x+y

`generators`
(Yield123()) coroutine
	<^>1
	<^>2
	<^>3

`matching is valid in a module body`
x = Yield123() `an inline comment`
(!)x
    0: print('matched 0') `a comment here too`
    1: print('matched 1')
  ...: print('matched any')

`matching is valid in a function body`
(Match(x = 0 -> int)) int
    (!)x
        0: Add(x, 1)
        1: Add(x, 2)
      ...: Add(x, 3)
    <*>x

`matching is also valid in a loop body`
i<@>Yield123()
    (!)i
        0: print('matched 0')
        1: print('matched 1')
      ...: print('matched any')


i<@>Yield123()
    print(i)

l = [1,2,3]
i<@>l
    print(i)

i<@>[1,2,3]
    print(i)

i<@>(1,2,3)
    print(i)

i<@>{1,2,3}
    print(i)

k,v<@>{'a': 0, 'b': 2}
    print(v)

i<@>"abcdefg"
    print(i)


`procedures`
(Hello()) procedure
	print("Hello, World!")

nullity = /0

test_factorial = 5!

test_unary_add = +5

test_unary_sub = -5

(FirstElem(x = [0] -> list(type(t)))) type(t)
    <*>x[0:1]

`persistent vectors`
D = [2, 4, 6, 8, 10]
`evolver vectors`
E = [12, 14, 16, 18]...

`persistent sets`
G = {'a', 'b', 'c'}
`evolver sets`
F = {'e', 'f', 'g'}...

`persistent mappings`
C = {'a': (3+5), 'b': 8, 'c': True, 4: None, 'd': 6**2*5+3}
`evolver mappings`
B = {'a': (3+5), 'b': 8, 'c': True, 4: None, 'd': 6**2*5+3}...


`new contracts can impose more complex contractual clauses`
colors <- list[3](int, <256)

`any woma function can be closed in place to become an instance that complies with the`
`type specification or Undefined for instances that breach the type specification contract`
x = Add(3, 3)...

`seamless exception handling allows tracing of undefined code branches`
y = Add(4, 3.5)...

`mixed usage of closure and regular function calls`
z = Add(x(), 3)

`Scala-style closure functions`
scala = (_ * 2)
val = scala(_ + _)
`This will be Undefined because of arity`
val = val(scala)...

`modulus and division by 0 handled by returning Undefined()`
denom = 0
chained = ---+---+-1 / 2 / 1
div_by_zero = 1 / denom
mod_zero = 1 % denom
div_by_zero2 = 1 / 0
mod_zero2 = 1 % 0
truth = 1 + 1 == 2 >> 0

main:
Hello()
print("I'm a binary.")