`first-class functions`
(Add(x = 3 -> int; y = 3 -> int)) int
	<*>x+y

`generators`
(Yield123()) coroutine
	<^>1
	<^>2
	<^>3

`matching is valid in a module body`
x = Yield123() `an inline comment`
(!)x
    0: 'matched 0' `a comment here too`
    1: 'matched 1'
  ...: 'matched any'

`matching is valid in a function body`
(Match(x = 0 -> int)) procedure
    (!)x
        0: 'I was called without arguments.'
        1: 'I was called with an argument of 1.'
      ...: 'I was called with any other integer argument.'

`matching is also valid in a loop body`
i<@>Yield123()
    (!)i
        0: 'matched 0'
        1: 'matched 1'
      ...: 'matched any'


i<@>Yield123()
    print(i)

l = [1,2,3]
i<@>l
    print(i)

i<@>[1,2,3]
    print(i)

i<@>(1,2,3)
    print(i)

i<@>{1,2,3}
    print(i)

k,v<@>{'a': 0, 'b': 2}
    print(v)

i<@>"abcdefg"
    print(i)


`procedures`
(Hello()) procedure
	print("Hello, World!")

nullity = /0

test_factorial = 5!

test_unary_add = +5

test_unary_sub = -5

golden = 1 + 5 ** 0.5 / 2

(Fibonacci(x = 0 -> int)) int
    g = 5 ** .5 -> float
    f = golden ** x -> float
    e = g // f -> int
    <*>e

(FirstElem(x = [0] -> list(type(t)))) type(t)
    <*>x[0:1]

`persistent vectors`
D = [2, 4, 6, 8, 10]
`evolver vectors`
E = [12, 14, 16, 18]...

`persistent sets`
G = {'a', 'b', 'c'}
`evolver sets`
F = {'e', 'f', 'g'}...

`persistent mappings`
C = {'a': (3+5), 'b': 8, 'c': True, 4: None, 'd': 6**2*5+3}
`evolver mappings`
B = {'a': (3+5), 'b': 8, 'c': True, 4: None, 'd': 6**2*5+3}...

`persistent sets`

`new contracts can impose more complex contractual clauses`
colors <- list[3](int, <256)

`any woma function can be closed in place to become an instance that complies with the`
`type specification or Undefined for instances that breach the type specification contract`
x = Add(3, 3)...

`seamless exception handling allows tracing of undefined code branches`
y = Add(4, 3.5)...

`mixed usage of closure and regular function calls`
z = Add(x(), 3)

`Scala-style closure functions`
scala = (_ * 2)
val = scala(_ + _)
`This will be Undefined because of arity`
val = val(scala)...

`modulus and division by 0 handled by returning Undefined()`
denom = 0
div_by_zero = 1 / denom
mod_zero = 1 % denom
div_by_zero2 = 1 / 0
mod_zero2 = 1 % 0
truth = 1 + 1 == 2 >> 0

main:
Hello()
print("I'm a binary.")